# 0.1.x API Reference (UNSTABLE)


- [Pipedator](#pipedator)
  - [Core](#core)
  - [Validators](#validators)
    - [`abstractShape`](#validator-abstractShape)
	- [`alt(validators: Validator[], message?: string): Validator`](#altvalidators-validator-message-string-validator)
	- [`alternative(validators: Validator[], message?: string): Validator`](#alternativevalidators-validator-message-string-validator)
	- [`both(validators: Validator[], message?: string): Validator`](#bothvalidators-validator-message-string-validator)
    - [`either(validators: Validator[], message?: string): Validator`](#eithervalidators-validator-message-string-validator)
    - [`empty(message?: string): Validator`](#emptymessage-string-validator)
  - [Interfaces](#interfaces)
    - [`Validator`](#validator)


# Pipedator


## Core

This library is inspired by `pipe`s from [rxjs](https://rxjs-dev.firebaseapp.com/).
The core of the pipedator is `createValidator` function which can be imported from core:

```typescript
import { createValidator } from 'pipedator';
// or
import { createValidator } from 'pipedator/lib/core';
```

`createValidator` is used to create any validators and has the next shape:
```typescript
function createValidator<ValidValue = any>(options: CreateValidatorOptions): Validator<ValidValue> {}
```
- `options` - is an object
- `options.validate` - is a function which takes current value as the first argument and current context as the second one and returns either null when value is valid or an error generated by context.

For example, to create a validator which checks whether the value is a number or not we can write this:
```typescript
// It is recommended to have a possibility to set a custom message for generated error.
function number(message?: string) {
	return createValidator({
		validate: (value, ctx) =>
			typeof value === 'number'
				? // We return null because value satisfies our condition to be a number
				  null
				: // This method from context generate an error and we need to return it when value is invalid
				  ctx.generateError({
						value,
						// Here we can use custom message
						message: message || 'Value should be a number',
						path: ctx.path,
				  }),
	});
}
```


## Validators


### `alt(validators: Validator[], message?: string): Validator`
```typescript
import { alt } from 'pipedator';
// or
import { alt } from 'pipedator/lib/alt';

```
An alias for [`alternative`](#alternativevalidators-validator-message-string-validator)


### `alternative(validators: Validator[], message?: string): Validator`
```typescript
import { alternative } from 'pipedator';
// or
import { alternative } from 'pipedator/lib/alternative';

```
Creates new validator which succeedes when at least one validator from `validators` does.
- `validators` - an array of [Validator](#validator).
- `message` - an optional string which can be used to overwrite error message.
```typescript
const numberOrString = alternative([string(), number()]);
// numberOrString will succeed when provided value is either string or number:
numberOrString.validate(4) // valid
numberOrString.validate('text') // valid
numberOrString.validate({}) // invalid
```

### `both(validators: Validator[], message?: string): Validator`
```typescript
import { both } from 'pipedator';
// or
import { both } from 'pipedator/lib/both';

```
An alias for [`pipe`](#pipevalidators-validator-message-string-validator)


### `either(validators: Validator[], message?: string): Validator`
```typescript
import { either } from 'pipedator';
// or
import { either } from 'pipedator/lib/either';

```
An alias for [`alternative`](#alternativevalidators-validator-message-string-validator)


### `empty(message?: string): Validator`
```typescript
import { empty } from 'pipedator';
// or
import { empty } from 'pipedator/lib/empty';

```
Creates new validator which succeedes when value is empty.

*Notes*:
- Value is empty when `value.length === 0`
- This validator requires value to be defined:

```typescript
const validator = empty();

validator.validate(''); // valid
validator.validate('not empty string'); // invalid
validator.validate([]); // valid
validator.validate([1]); // invalid
validator.validate({ length: 0 }); // valid
validator.validate(null); // throws an error (trying to read property length from null)
validator.validate(undefined); // throws an error (trying to read property length from undefined)

```


## Interfaces

### `Validator`
